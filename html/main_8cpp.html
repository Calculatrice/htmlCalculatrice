<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Calculatrice: Référence du fichier /home/etudiant/CodeCalculatrice/main.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Calculatrice
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Recherche');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Page&#160;principale</span></a></li>
      <li class="current"><a href="files.html"><span>Fichiers</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Recherche" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>Liste&#160;des&#160;fichiers</span></a></li>
      <li><a href="globals.html"><span>Membres&#160;de&#160;fichier</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Tout</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Fichiers</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Fonctions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70a4a8285b80e6379f58d0b384682cd9.html">CodeCalculatrice</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Fonctions</a>  </div>
  <div class="headertitle">
<div class="title">Référence du fichier main.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Graphe des dépendances par inclusion de main.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="main_8cpp__incl.png" border="0" usemap="#_2home_2etudiant_2_code_calculatrice_2main_8cpp" alt=""/></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Fonctions</h2></td></tr>
<tr class="memitem:a74eeca5180d37e66b5252409b2edeb61"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a74eeca5180d37e66b5252409b2edeb61">addition</a> (int32_t opA, int32_t opB)</td></tr>
<tr class="memdesc:a74eeca5180d37e66b5252409b2edeb61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction d'addition de deux nombres de type int32_t.  <a href="#a74eeca5180d37e66b5252409b2edeb61">Plus de détails...</a><br /></td></tr>
<tr class="separator:a74eeca5180d37e66b5252409b2edeb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdd3e7a0725b2197c954758e228c47c"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#abbdd3e7a0725b2197c954758e228c47c">addition</a> (int64_t opA, int64_t opB)</td></tr>
<tr class="memdesc:abbdd3e7a0725b2197c954758e228c47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction d'addition de deux nombres de type int64_t.  <a href="#abbdd3e7a0725b2197c954758e228c47c">Plus de détails...</a><br /></td></tr>
<tr class="separator:abbdd3e7a0725b2197c954758e228c47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b147523f412f566758b7b7bd6d809e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#ae9b147523f412f566758b7b7bd6d809e">addition</a> (float opA, float opB)</td></tr>
<tr class="memdesc:ae9b147523f412f566758b7b7bd6d809e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction d'addition de deux nombres de type float.  <a href="#ae9b147523f412f566758b7b7bd6d809e">Plus de détails...</a><br /></td></tr>
<tr class="separator:ae9b147523f412f566758b7b7bd6d809e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd7eed5fa1b429c19d5c06186648019"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#affd7eed5fa1b429c19d5c06186648019">addition</a> (double opA, double opB)</td></tr>
<tr class="memdesc:affd7eed5fa1b429c19d5c06186648019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction d'addition de deux nombres de type double.  <a href="#affd7eed5fa1b429c19d5c06186648019">Plus de détails...</a><br /></td></tr>
<tr class="separator:affd7eed5fa1b429c19d5c06186648019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e2eb8014fffffcd1cf01bec5922db2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#ac3e2eb8014fffffcd1cf01bec5922db2">soustraction</a> (int32_t opA, int32_t opB)</td></tr>
<tr class="memdesc:ac3e2eb8014fffffcd1cf01bec5922db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction de soustraction de deux nombres de type int32_t.  <a href="#ac3e2eb8014fffffcd1cf01bec5922db2">Plus de détails...</a><br /></td></tr>
<tr class="separator:ac3e2eb8014fffffcd1cf01bec5922db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad299f9009dd8993c54a3e13c89bf71fa"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#ad299f9009dd8993c54a3e13c89bf71fa">soustraction</a> (int64_t opA, int64_t opB)</td></tr>
<tr class="memdesc:ad299f9009dd8993c54a3e13c89bf71fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction de soustraction de deux nombres de type int64_t.  <a href="#ad299f9009dd8993c54a3e13c89bf71fa">Plus de détails...</a><br /></td></tr>
<tr class="separator:ad299f9009dd8993c54a3e13c89bf71fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1129901886b4419af8e95a923e82c55e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a1129901886b4419af8e95a923e82c55e">soustraction</a> (float opA, float opB)</td></tr>
<tr class="memdesc:a1129901886b4419af8e95a923e82c55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction de soustraction de deux nombres de type float.  <a href="#a1129901886b4419af8e95a923e82c55e">Plus de détails...</a><br /></td></tr>
<tr class="separator:a1129901886b4419af8e95a923e82c55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc37c8c5fc925b2e0de4410b80e635e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#afdc37c8c5fc925b2e0de4410b80e635e">soustraction</a> (double opA, double opB)</td></tr>
<tr class="memdesc:afdc37c8c5fc925b2e0de4410b80e635e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction de soustraction de deux nombres de type double.  <a href="#afdc37c8c5fc925b2e0de4410b80e635e">Plus de détails...</a><br /></td></tr>
<tr class="separator:afdc37c8c5fc925b2e0de4410b80e635e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dad3a33be2ce2d463a66b2fb480dc80"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a5dad3a33be2ce2d463a66b2fb480dc80">multiplication</a> (int32_t opA, int32_t opB)</td></tr>
<tr class="memdesc:a5dad3a33be2ce2d463a66b2fb480dc80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction de multiplication de deux nombres de type int32_t.  <a href="#a5dad3a33be2ce2d463a66b2fb480dc80">Plus de détails...</a><br /></td></tr>
<tr class="separator:a5dad3a33be2ce2d463a66b2fb480dc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8e7a49c10851ab80c6bdd6a9768449"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a3b8e7a49c10851ab80c6bdd6a9768449">multiplication</a> (int64_t opA, int64_t opB)</td></tr>
<tr class="memdesc:a3b8e7a49c10851ab80c6bdd6a9768449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction de multiplication de deux nombres de type int64_t.  <a href="#a3b8e7a49c10851ab80c6bdd6a9768449">Plus de détails...</a><br /></td></tr>
<tr class="separator:a3b8e7a49c10851ab80c6bdd6a9768449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110ae188262e21caa53c8c0228351635"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a110ae188262e21caa53c8c0228351635">multiplication</a> (float opA, float opB)</td></tr>
<tr class="memdesc:a110ae188262e21caa53c8c0228351635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction de multiplication de deux nombres de type float.  <a href="#a110ae188262e21caa53c8c0228351635">Plus de détails...</a><br /></td></tr>
<tr class="separator:a110ae188262e21caa53c8c0228351635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8125230d07c8f775eae0b75b69285f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a5a8125230d07c8f775eae0b75b69285f">multiplication</a> (double opA, double opB)</td></tr>
<tr class="memdesc:a5a8125230d07c8f775eae0b75b69285f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction de multiplication de deux nombres de type double.  <a href="#a5a8125230d07c8f775eae0b75b69285f">Plus de détails...</a><br /></td></tr>
<tr class="separator:a5a8125230d07c8f775eae0b75b69285f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7560da830b8c7d4f0c477c04a8a6d552"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a7560da830b8c7d4f0c477c04a8a6d552">division</a> (int32_t opA, int32_t opB)</td></tr>
<tr class="memdesc:a7560da830b8c7d4f0c477c04a8a6d552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction de division de deux nombres de type int32_t.  <a href="#a7560da830b8c7d4f0c477c04a8a6d552">Plus de détails...</a><br /></td></tr>
<tr class="separator:a7560da830b8c7d4f0c477c04a8a6d552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d603d1dbdfe363637540ae067506d8e"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a4d603d1dbdfe363637540ae067506d8e">division</a> (int64_t opA, int64_t opB)</td></tr>
<tr class="memdesc:a4d603d1dbdfe363637540ae067506d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction de division de deux nombres de type int64_t.  <a href="#a4d603d1dbdfe363637540ae067506d8e">Plus de détails...</a><br /></td></tr>
<tr class="separator:a4d603d1dbdfe363637540ae067506d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e964319cf0c87b0d583cf9f0a230185"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a2e964319cf0c87b0d583cf9f0a230185">division</a> (float opA, float opB)</td></tr>
<tr class="memdesc:a2e964319cf0c87b0d583cf9f0a230185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction de division de deux nombres de type float.  <a href="#a2e964319cf0c87b0d583cf9f0a230185">Plus de détails...</a><br /></td></tr>
<tr class="separator:a2e964319cf0c87b0d583cf9f0a230185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbe3a00771167b143af1c4a69bf1633"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#adbbe3a00771167b143af1c4a69bf1633">division</a> (double opA, double opB)</td></tr>
<tr class="memdesc:adbbe3a00771167b143af1c4a69bf1633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction de division de deux nombres de type double.  <a href="#adbbe3a00771167b143af1c4a69bf1633">Plus de détails...</a><br /></td></tr>
<tr class="separator:adbbe3a00771167b143af1c4a69bf1633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f5ab9b12d769927a7eaa459051a167"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a84f5ab9b12d769927a7eaa459051a167">modulo</a> (int32_t opA, int32_t opB)</td></tr>
<tr class="memdesc:a84f5ab9b12d769927a7eaa459051a167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction de modulo de deux nombres de type int32_t.  <a href="#a84f5ab9b12d769927a7eaa459051a167">Plus de détails...</a><br /></td></tr>
<tr class="separator:a84f5ab9b12d769927a7eaa459051a167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7337b3db310c74986b5be151d11beab3"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a7337b3db310c74986b5be151d11beab3">modulo</a> (int64_t opA, int64_t opB)</td></tr>
<tr class="memdesc:a7337b3db310c74986b5be151d11beab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction de modulo de deux nombres de type int64_t.  <a href="#a7337b3db310c74986b5be151d11beab3">Plus de détails...</a><br /></td></tr>
<tr class="separator:a7337b3db310c74986b5be151d11beab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7db196963fa4cfa7752eb4abae2924"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a6d7db196963fa4cfa7752eb4abae2924">entier32</a> ()</td></tr>
<tr class="memdesc:a6d7db196963fa4cfa7752eb4abae2924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction pour utiliser le type int32_t.  <a href="#a6d7db196963fa4cfa7752eb4abae2924">Plus de détails...</a><br /></td></tr>
<tr class="separator:a6d7db196963fa4cfa7752eb4abae2924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028c331b74591f474f5a8597b1f58b70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a028c331b74591f474f5a8597b1f58b70">entier64</a> ()</td></tr>
<tr class="memdesc:a028c331b74591f474f5a8597b1f58b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction pour utiliser le type int64_t.  <a href="#a028c331b74591f474f5a8597b1f58b70">Plus de détails...</a><br /></td></tr>
<tr class="separator:a028c331b74591f474f5a8597b1f58b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c0d2d4e298901dd2caefa34848eb06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#ab5c0d2d4e298901dd2caefa34848eb06">flottant</a> ()</td></tr>
<tr class="memdesc:ab5c0d2d4e298901dd2caefa34848eb06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction pour utiliser le type float.  <a href="#ab5c0d2d4e298901dd2caefa34848eb06">Plus de détails...</a><br /></td></tr>
<tr class="separator:ab5c0d2d4e298901dd2caefa34848eb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069cf496b85422f87b5311c45902759c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a069cf496b85422f87b5311c45902759c">nbdouble</a> ()</td></tr>
<tr class="memdesc:a069cf496b85422f87b5311c45902759c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction pour utiliser le type double.  <a href="#a069cf496b85422f87b5311c45902759c">Plus de détails...</a><br /></td></tr>
<tr class="separator:a069cf496b85422f87b5311c45902759c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> ()</td></tr>
<tr class="memdesc:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction principal executant le code.  <a href="#ae66f6b31b5ad750f1fe042a706a4e3d4">Plus de détails...</a><br /></td></tr>
<tr class="separator:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Documentation des fonctions</h2>
<a class="anchor" id="a74eeca5180d37e66b5252409b2edeb61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t addition </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>opB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction d'addition de deux nombres de type int32_t. </p>
<p>La fonction d'addition est polymorphe, c'est a dire qu'elle depend du type des parametres fournis. Celle-ci correspond au type int32_t.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">opA</td><td>un entier 32 bits </td></tr>
    <tr><td class="paramname">opB</td><td>un entier 32 bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>La somme des deux entiers 32bits fournis en parametres </dd></dl>
<dl class="section see"><dt>Voir également</dt><dd>ajouter(int64_t, int64_t). ajouter(double, double). ajouter(float, float) </dd></dl>

</div>
</div>
<a class="anchor" id="abbdd3e7a0725b2197c954758e228c47c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t addition </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>opB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction d'addition de deux nombres de type int64_t. </p>
<p>La fonction d'addition est polymorphe, c'est a dire qu'elle depend du type des parametres fournis. Celle-ci correspond au type int64_t.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">opA</td><td>un entier 64 bits </td></tr>
    <tr><td class="paramname">opB</td><td>un entier 64 bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>La somme des deux entiers 64bits fournis en parametres </dd></dl>
<dl class="section see"><dt>Voir également</dt><dd>ajouter(int32_t, int32_t). ajouter(double, double). ajouter(float, float) </dd></dl>

</div>
</div>
<a class="anchor" id="ae9b147523f412f566758b7b7bd6d809e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float addition </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction d'addition de deux nombres de type float. </p>
<p>La fonction d'addition est polymorphe, c'est a dire qu'elle depend du type des parametres fournis. Celle-ci correspond au type float</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">opA</td><td>un decimal float </td></tr>
    <tr><td class="paramname">opB</td><td>un decimal float </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>La somme des deux decimaux float fournis en parametres </dd></dl>
<dl class="section see"><dt>Voir également</dt><dd>ajouter(int64_t, int64_t). ajouter(double, double). ajouter(int32_t, int32_t) </dd></dl>

</div>
</div>
<a class="anchor" id="affd7eed5fa1b429c19d5c06186648019"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double addition </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>opB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction d'addition de deux nombres de type double. </p>
<p>La fonction d'addition est polymorphe, c'est a dire qu'elle depend du type des parametres fournis. Celle-ci correspond au type double</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">opA</td><td>un decimal double </td></tr>
    <tr><td class="paramname">opB</td><td>un decimal double </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>La somme des deux decimaux double fournis en parametres </dd></dl>
<dl class="section see"><dt>Voir également</dt><dd>ajouter(int64_t, int64_t). ajouter(int32_t, int32_t). ajouter(float, float) </dd></dl>

</div>
</div>
<a class="anchor" id="a7560da830b8c7d4f0c477c04a8a6d552"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t division </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>opB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction de division de deux nombres de type int32_t. </p>
<p>La fonction de division est une operation qui a deux nombres a et b associe un troisieme nombre, appele quotient. Celle-ci correspond au type int32_t</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">opA</td><td>un entier int32_t </td></tr>
    <tr><td class="paramname">opB</td><td>un entier int32_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>La difference des deux entiers fournis en parametres </dd></dl>
<dl class="section see"><dt>Voir également</dt><dd>ajouter(int64_t, int64_t). ajouter(double, double). ajouter(float, float) </dd></dl>

</div>
</div>
<a class="anchor" id="a4d603d1dbdfe363637540ae067506d8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t division </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>opB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction de division de deux nombres de type int64_t. </p>
<p>La fonction de division est une operation qui a deux nombres a et b associe un troisieme nombre, appele quotient. Celle-ci correspond au type int64_t</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">opA</td><td>un entier int64_t </td></tr>
    <tr><td class="paramname">opB</td><td>un entier int64_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>La difference des deux entiers fournis en parametres </dd></dl>
<dl class="section see"><dt>Voir également</dt><dd>ajouter(int32_t, int32_t). ajouter(double, double). ajouter(float, float) </dd></dl>

</div>
</div>
<a class="anchor" id="a2e964319cf0c87b0d583cf9f0a230185"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float division </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction de division de deux nombres de type float. </p>
<p>La fonction de division est une operation qui a deux nombres a et b associe un troisieme nombre, appele quotient. Celle-ci correspond au type float</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">opA</td><td>un decimal float </td></tr>
    <tr><td class="paramname">opB</td><td>un decimal float </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>La difference des deux entiers fournis en parametres </dd></dl>
<dl class="section see"><dt>Voir également</dt><dd>ajouter(int64_t, int64_t). ajouter(double, double). ajouter(int32_t, int32_t) </dd></dl>

</div>
</div>
<a class="anchor" id="adbbe3a00771167b143af1c4a69bf1633"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double division </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>opB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction de division de deux nombres de type double. </p>
<p>La fonction de division est une operation qui a deux nombres a et b associe un troisieme nombre, appele quotient. Celle-ci correspond au type double</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">opA</td><td>un decimal double </td></tr>
    <tr><td class="paramname">opB</td><td>un decimal double </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>La difference des deux entiers fournis en parametres </dd></dl>
<dl class="section see"><dt>Voir également</dt><dd>ajouter(int64_t, int64_t). ajouter(float, float). ajouter(int32_t, int32_t) </dd></dl>

</div>
</div>
<a class="anchor" id="a6d7db196963fa4cfa7752eb4abae2924"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void entier32 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction pour utiliser le type int32_t. </p>
<p>A l'interieur se trouve tout le programme permettant de demander les operateurs, l'operande et l'affichage du resultat. Celle-ci correspond au type int32_t</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="main_8cpp.html#a028c331b74591f474f5a8597b1f58b70" title="Fonction pour utiliser le type int64_t. ">entier64()</a>. <a class="el" href="main_8cpp.html#ab5c0d2d4e298901dd2caefa34848eb06" title="Fonction pour utiliser le type float. ">flottant()</a>. <a class="el" href="main_8cpp.html#a069cf496b85422f87b5311c45902759c" title="Fonction pour utiliser le type double. ">nbdouble()</a>. </dd></dl>
<p>Declaration et initialisation des variables</p>
<p>&lt; Declaration des variables opA et opB, utilisees lors du choix de l'utilisateur.</p>
<p>&lt; Declaration de la variable operation, utilisee lors du choix de l'utilisateur.</p>
<p>&lt; Declaration et initialisation des variables utilise pour la verification des choix de l'utilisateur.</p>
<p>Affichage a l'utilisateur de la demande des operateurs L'utilisateur choisi ses deux operateurs, attention l'ordre est important si on utilise la soustraction ou la division. Le choix est enregistre dans les variables opA et opB.</p>
<p>Boucle de verification.</p>
<p>La boucle while permet la verification pour la question a propos du choix de l'operande a utiliser entre addiction, soustraction, multiplication, division, et division euclidienne. Tant que la variable verifop est regle sur "faux", le programme continu dans la boucle.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">verifop</td><td>est un booleen</td></tr>
  </table>
  </dd>
</dl>
<p>Affichage a l'utilisateur de la demande de l'operande L'utilisateur choisi entre 5 nombres pour choisir son operande. Le choix est enregistre dans la variable operation.</p>
<p>Structure de controle Le choix de l'operande est utilise comme parametre et le nombre choisi permet de lancer la fonction correspondant a l'option.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>est un entier</td></tr>
  </table>
  </dd>
</dl>
<p>Premiere option :</p>
<p>Ce premier "case" lance la fonction addition avec comme parametres les deux operateurs. La variable de verification verifop est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>Deuxieme option :</p>
<p>Ce deuxieme "case" lance la fonction soustraction avec comme parametres les deux operateurs.</p>
<p>La variable de verification verifop est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>Troisieme option :</p>
<p>Ce troisieme "case" lance la fonction multiplication avec comme parametres les deux operateurs. La variable de verification verifop est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>Quatrieme option :</p>
<p>Ce quatrieme "case" lance la fonction division avec comme parametres les deux operateurs. La variable de verification verifop est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>Cinquieme option :</p>
<p>Ce cinquieme "case" lance la fonction modulo avec comme parametres les deux operateurs. La variable de verification verifop est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>L'option par defaut :</p>
<p>Cette option permet d'indiquer a l'utilisateur une erreur de saisie, car si les precedentes options ne sont pas lancees, forcement il y a une erreur de saisie lors du choix du type a utiliser. </p>

</div>
</div>
<a class="anchor" id="a028c331b74591f474f5a8597b1f58b70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void entier64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction pour utiliser le type int64_t. </p>
<p>A l'interieur se trouve tout le programme permettant de demander les operateurs, l'operande et l'affichage du resultat. Celle-ci correspond au type int64_t</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="main_8cpp.html#a6d7db196963fa4cfa7752eb4abae2924" title="Fonction pour utiliser le type int32_t. ">entier32()</a>. <a class="el" href="main_8cpp.html#ab5c0d2d4e298901dd2caefa34848eb06" title="Fonction pour utiliser le type float. ">flottant()</a>. <a class="el" href="main_8cpp.html#a069cf496b85422f87b5311c45902759c" title="Fonction pour utiliser le type double. ">nbdouble()</a>. </dd></dl>
<p>Declaration et initialisation des variables</p>
<p>&lt; Declaration des variables opA et opB, utilisees lors du choix de l'utilisateur.</p>
<p>&lt; Declaration de la variable operation, utilisee lors du choix de l'utilisateur.</p>
<p>&lt; Declaration et initialisation des variables utilise pour la verification des choix de l'utilisateur.</p>
<p>Affichage a l'utilisateur de la demande des operateurs L'utilisateur choisi ses deux operateurs, attention l'ordre est important si on utilise la soustraction ou la division. Le choix est enregistre dans les variables opA et opB.</p>
<p>Boucle de verification.</p>
<p>La boucle while permet la verification pour la question a propos du choix de l'operande a utiliser entre addiction, soustraction, multiplication, division, et division euclidienne. Tant que la variable verifop est regle sur "faux", le programme continu dans la boucle.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">verifop</td><td>est un booleen</td></tr>
  </table>
  </dd>
</dl>
<p>Affichage a l'utilisateur de la demande de l'operande L'utilisateur choisi entre 5 nombres pour choisir son operande. Le choix est enregistre dans la variable operation.</p>
<p>Structure de controle Le choix de l'operande est utilise comme parametre et le nombre choisi permet de lancer la fonction correspondant a l'option.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>est un entier</td></tr>
  </table>
  </dd>
</dl>
<p>Premiere option</p>
<p>Ce premier "case" lance la fonction addition avec comme parametres les deux operateurs. La variable de verification verifop est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>Deuxieme option</p>
<p>Ce deuxieme "case" lance la fonction soustraction avec comme parametres les deux operateurs. La variable de verification verifop est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>Troisieme option</p>
<p>Ce troisieme "case" lance la fonction multiplication avec comme parametres les deux operateurs. La variable de verification verifop est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>Quatrieme option</p>
<p>Ce quatrieme "case" lance la fonction division avec comme parametres les deux operateurs. La variable de verification verifop est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>Cinquieme option</p>
<p>Ce cinquieme "case" lance la fonction modulo avec comme parametres les deux operateurs. La variable de verification verifop est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>L'option par defaut</p>
<p>Cette option permet d'indiquer a l'utilisateur une erreur de saisie, car si les precedentes options ne sont pas lancees, forcement il y a une erreur de saisie lors du choix du type a utiliser. </p>

</div>
</div>
<a class="anchor" id="ab5c0d2d4e298901dd2caefa34848eb06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flottant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction pour utiliser le type float. </p>
<p>A l'interieur se trouve tout le programme permettant de demander les operateurs, l'operande et l'affichage du resultat. Celle-ci correspond au type float</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="main_8cpp.html#a6d7db196963fa4cfa7752eb4abae2924" title="Fonction pour utiliser le type int32_t. ">entier32()</a>. <a class="el" href="main_8cpp.html#a028c331b74591f474f5a8597b1f58b70" title="Fonction pour utiliser le type int64_t. ">entier64()</a>. <a class="el" href="main_8cpp.html#a069cf496b85422f87b5311c45902759c" title="Fonction pour utiliser le type double. ">nbdouble()</a>. </dd></dl>
<p>Declaration et initialisation des variables</p>
<p>&lt; Declaration des variables opA et opB, utilisees lors du choix de l'utilisateur.</p>
<p>&lt; Declaration de la variable operation, utilisee lors du choix de l'utilisateur.</p>
<p>&lt; Declaration et initialisation des variables utilise pour la verification des choix de l'utilisateur.</p>
<p>Affichage a l'utilisateur de la demande des operateurs L'utilisateur choisi ses deux operateurs, attention l'ordre est important si on utilise la soustraction ou la division. Le choix est enregistre dans les variables opA et opB.</p>
<p>Boucle de verification.</p>
<p>La boucle while permet la verification pour la question a propos du choix de l'operande a utiliser entre addiction, soustraction, multiplication, et division. Tant que la variable verifop est regle sur "faux", le programme continu dans la boucle.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">verifop</td><td>est un booleen</td></tr>
  </table>
  </dd>
</dl>
<p>Affichage a l'utilisateur de la demande de l'operande L'utilisateur choisi entre 4 nombres pour choisir son operande. Le choix est enregistre dans la variable operation.</p>
<p>Structure de controle Le choix de l'operande est utilise comme parametre et le nombre choisi permet de lancer la fonction correspondant a l'option.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>est un entier</td></tr>
  </table>
  </dd>
</dl>
<p>Premiere option</p>
<p>Ce premier "case" lance la fonction addition avec comme parametres les deux operateurs. La variable de verification verifop est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>Deuxieme option</p>
<p>Ce deuxieme "case" lance la fonction soustraction avec comme parametres les deux operateurs. La variable de verification verifop est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>Troisieme option</p>
<p>Ce troisieme "case" lance la fonction multiplication avec comme parametres les deux operateurs. La variable de verification verifop est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>Quatrieme option</p>
<p>Ce quatrieme "case" lance la fonction division avec comme parametres les deux operateurs. La variable de verification verifop est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>L'option par defaut</p>
<p>Cette option permet d'indiquer a l'utilisateur une erreur de saisie, car si les precedentes options ne sont pas lancees, forcement il y a une erreur de saisie lors du choix du type a utiliser. </p>

</div>
</div>
<a class="anchor" id="ae66f6b31b5ad750f1fe042a706a4e3d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction principal executant le code. </p>
<p>Declaration et initialisation des variables</p>
<p>&lt; Declaration de la variable type, utilisee lors du choix de l'utilisateur.</p>
<p>&lt; Declaration et initialisation de la variable utilisee pour la verification des choix de l'utilisateur.</p>
<p>Boucle de verification.</p>
<p>La boucle while permet la verification pour la question a propos du choix du type a utiliser entre int32_t, int64_t, float et double. Tant que la variable veriftype est regle sur "faux", le programme continu dans la boucle.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">veriftype</td><td>est un booleen</td></tr>
  </table>
  </dd>
</dl>
<p>Affichage a l'utilisateur de la demande du type a utiliser. L'utilisateur doit choisir entre 4 nombre pour choisir son type.</p>
<p>Le choix est enregistre dans la variable type.</p>
<p>Structure de controle Le choix du type est utilise comme parametre et le nombre choisi permet de lancer la fonction correspondant a l'option.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>est un entier</td></tr>
  </table>
  </dd>
</dl>
<p>Premiere option</p>
<p>Ce premier "case" lance la fonction entier32 pour le type int32_t. La variable de verification veriftype est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>Deuxieme option</p>
<p>Ce deuxieme "case" lance la fonction entier64 pour le type int64_t. La variable de verification veriftype est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>Troisieme option</p>
<p>Ce troisieme "case" lance la fonction flottant pour le type float. La variable de verification veriftype est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>Quatrieme option</p>
<p>Ce quatrieme "case" lance la fonction nbdouble pour le type double. La variable de verification veriftype est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>L'option par defaut</p>
<p>Cette option permet d'indiquer a l'utilisateur une erreur de saisie, car si les precedentes options ne sont pas lancees, forcement il y a une erreur de saisie lors du choix du type a utiliser. </p>

</div>
</div>
<a class="anchor" id="a84f5ab9b12d769927a7eaa459051a167"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t modulo </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>opB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction de modulo de deux nombres de type int32_t. </p>
<p>La fonction de modulo correspond a l'operation de calcul du reste de la division euclidienne. Celle-ci correspond au type int32_t</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">opA</td><td>un entier int32_t </td></tr>
    <tr><td class="paramname">opB</td><td>un entier int32_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>La difference des deux entiers fournis en parametres </dd></dl>
<dl class="section see"><dt>Voir également</dt><dd>ajouter(int64_t, int64_t). </dd></dl>

</div>
</div>
<a class="anchor" id="a7337b3db310c74986b5be151d11beab3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t modulo </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>opB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction de modulo de deux nombres de type int64_t. </p>
<p>La fonction de modulo correspond a l'operation de calcul du reste de la division euclidienne. Celle-ci correspond au type int64_t</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">opA</td><td>un entier int64_t </td></tr>
    <tr><td class="paramname">opB</td><td>un entier int64_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>La difference des deux entiers fournis en parametres </dd></dl>
<dl class="section see"><dt>Voir également</dt><dd>ajouter(int32_t, int32_t). </dd></dl>

</div>
</div>
<a class="anchor" id="a5dad3a33be2ce2d463a66b2fb480dc80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t multiplication </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>opB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction de multiplication de deux nombres de type int32_t. </p>
<p>La fonction de multiplication est une "addition repetee" autant de fois que necessaire. Son resultat est un produit. Celle-ci correspond au type 32 bits.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">opA</td><td>un entier 32 bits </td></tr>
    <tr><td class="paramname">opB</td><td>un entier 32 bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>La difference des deux entiers fournis en parametres </dd></dl>
<dl class="section see"><dt>Voir également</dt><dd>ajouter(int64_t, int64_t). ajouter(double, double). ajouter(float, float) </dd></dl>

</div>
</div>
<a class="anchor" id="a3b8e7a49c10851ab80c6bdd6a9768449"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t multiplication </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>opB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction de multiplication de deux nombres de type int64_t. </p>
<p>La fonction de multiplication est une "addition repetee" autant de fois que necessaire. Son resultat est un produit. Celle-ci correspond au type 64 bits.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">opA</td><td>un entier 64 bits </td></tr>
    <tr><td class="paramname">opB</td><td>un entier 64 bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>La difference des deux entiers fournis en parametres </dd></dl>
<dl class="section see"><dt>Voir également</dt><dd>ajouter(int32_t, int32_t). ajouter(double, double). ajouter(float, float) </dd></dl>

</div>
</div>
<a class="anchor" id="a110ae188262e21caa53c8c0228351635"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float multiplication </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction de multiplication de deux nombres de type float. </p>
<p>La fonction de multiplication est une "addition repetee" autant de fois que necessaire. Son resultat est un produit. Celle-ci correspond au type float</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">opA</td><td>un decimal float </td></tr>
    <tr><td class="paramname">opB</td><td>un decimal float </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>La difference des deux entiers fournis en parametres </dd></dl>
<dl class="section see"><dt>Voir également</dt><dd>ajouter(int64_t, int64_t). ajouter(double, double). ajouter(int32_t, int32_t) </dd></dl>

</div>
</div>
<a class="anchor" id="a5a8125230d07c8f775eae0b75b69285f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double multiplication </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>opB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction de multiplication de deux nombres de type double. </p>
<p>La fonction de multiplication est une "addition repetee" autant de fois que necessaire. Son resultat est un produit. Celle-ci correspond au type double</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">opA</td><td>un decimal double </td></tr>
    <tr><td class="paramname">opB</td><td>un decimal double </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>La difference des deux entiers fournis en parametres </dd></dl>
<dl class="section see"><dt>Voir également</dt><dd>ajouter(int64_t, int64_t). ajouter(float, float). ajouter(int32_t, int32_t) </dd></dl>

</div>
</div>
<a class="anchor" id="a069cf496b85422f87b5311c45902759c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nbdouble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction pour utiliser le type double. </p>
<p>A l'interieur se trouve tout le programme permettant de demander les operateurs, l'operande et l'affichage du resultat. Celle-ci correspond au type double</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="main_8cpp.html#a6d7db196963fa4cfa7752eb4abae2924" title="Fonction pour utiliser le type int32_t. ">entier32()</a>. <a class="el" href="main_8cpp.html#a028c331b74591f474f5a8597b1f58b70" title="Fonction pour utiliser le type int64_t. ">entier64()</a>. <a class="el" href="main_8cpp.html#ab5c0d2d4e298901dd2caefa34848eb06" title="Fonction pour utiliser le type float. ">flottant()</a>. </dd></dl>
<p>Declaration et initialisation des variables</p>
<p>&lt; Declaration des variables opA et opB, utilisees lors du choix de l'utilisateur.</p>
<p>&lt; Declaration de la variable operation, utilisee lors du choix de l'utilisateur.</p>
<p>&lt; Declaration et initialisation des variables utilise pour la verification des choix de l'utilisateur.</p>
<p>Affichage a l'utilisateur de la demande des operateurs L'utilisateur choisi ses deux operateurs, attention l'ordre est important si on utilise la soustraction ou la division. Le choix est enregistre dans les variables opA et opB.</p>
<p>Boucle de verification.</p>
<p>La boucle while permet la verification pour la question a propos du choix de l'operande a utiliser entre addiction, soustraction, multiplication, et division. Tant que la variable verifop est regle sur "faux", le programme continu dans la boucle.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">verifop</td><td>est un booleen</td></tr>
  </table>
  </dd>
</dl>
<p>Affichage a l'utilisateur de la demande de l'operande L'utilisateur choisi entre 4 nombres pour choisir son operande. Le choix est enregistre dans la variable operation.</p>
<p>Structure de controle Le choix de l'operande est utilise comme parametre et le nombre choisi permet de lancer la fonction correspondant a l'option.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>est un entier</td></tr>
  </table>
  </dd>
</dl>
<p>Premiere option</p>
<p>Ce premier "case" lance la fonction addition avec comme parametres les deux operateurs. La variable de verification verifop est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>Deuxieme option</p>
<p>Ce deuxieme "case" lance la fonction soustraction avec comme parametres les deux operateurs. La variable de verification verifop est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>Troisieme option</p>
<p>Ce troisieme "case" lance la fonction multiplication avec comme parametres les deux operateurs. La variable de verification verifop est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>Quatrieme option</p>
<p>Ce quatrieme "case" lance la fonction division avec comme parametres les deux operateurs. La variable de verification verifop est regle sur "vrai" pour sortir de la boucle de verification.</p>
<p>L'option par defaut</p>
<p>Cette option permet d'indiquer a l'utilisateur une erreur de saisie, car si les precedentes options ne sont pas lancees, forcement il y a une erreur de saisie lors du choix du type a utiliser. </p>

</div>
</div>
<a class="anchor" id="ac3e2eb8014fffffcd1cf01bec5922db2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t soustraction </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>opB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction de soustraction de deux nombres de type int32_t. </p>
<p>La fonction de soustraction combine deux nombres de meme type pour donner un seul nombre : la difference. Celle-ci correspond au type 32 bits.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">opA</td><td>un entier 32 bits </td></tr>
    <tr><td class="paramname">opB</td><td>un entier 32 bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>La difference des deux entiers fournis en parametres </dd></dl>
<dl class="section see"><dt>Voir également</dt><dd>ajouter(int64_t, int64_t). ajouter(double, double). ajouter(float, float) </dd></dl>

</div>
</div>
<a class="anchor" id="ad299f9009dd8993c54a3e13c89bf71fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t soustraction </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>opB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction de soustraction de deux nombres de type int64_t. </p>
<p>La fonction de soustraction combine deux nombres de meme type pour donner un seul nombre : la difference. Celle-ci correspond au type 64 bits.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">opA</td><td>un entier 64 bits </td></tr>
    <tr><td class="paramname">opB</td><td>un entier 64 bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>La difference des deux entiers fournis en parametres </dd></dl>
<dl class="section see"><dt>Voir également</dt><dd>ajouter(int32_t, int32_t). ajouter(double, double). ajouter(float, float) </dd></dl>

</div>
</div>
<a class="anchor" id="a1129901886b4419af8e95a923e82c55e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float soustraction </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction de soustraction de deux nombres de type float. </p>
<p>La fonction de soustraction combine deux nombres de meme type pour donner un seul nombre : la difference. Celle-ci correspond au type float</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">opA</td><td>un decimal float </td></tr>
    <tr><td class="paramname">opB</td><td>un decimal float </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>La difference des deux entiers fournis en parametres </dd></dl>
<dl class="section see"><dt>Voir également</dt><dd>ajouter(int32_t, int32_t). ajouter(double, double). ajouter(int64_t, int64_t) </dd></dl>

</div>
</div>
<a class="anchor" id="afdc37c8c5fc925b2e0de4410b80e635e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double soustraction </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>opB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction de soustraction de deux nombres de type double. </p>
<p>La fonction de soustraction combine deux nombres de meme type pour donner un seul nombre : la difference. Celle-ci correspond au type double</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">opA</td><td>un decimal double </td></tr>
    <tr><td class="paramname">opB</td><td>un decimal double </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>La difference des deux entiers fournis en parametres </dd></dl>
<dl class="section see"><dt>Voir également</dt><dd>ajouter(int32_t, int32_t). ajouter(float, float). ajouter(int64_t, int64_t) </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Généré le Lundi 23 Février 2015 14:19:48 pour Calculatrice par &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
